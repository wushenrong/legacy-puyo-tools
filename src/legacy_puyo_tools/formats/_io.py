# SPDX-FileCopyrightText: 2025 Samuel Wu
#
# SPDX-License-Identifier: MIT-0
#
# Some of the following code is generated by ChatGPT with modifications, and is generic
# enough that a public domain equivalent license can be applied.

"""Functions to deal with file operations."""

from __future__ import annotations

import os
from codecs import BOM_UTF16_LE
from pathlib import Path
from typing import BinaryIO, Literal

UTF16_LENGTH = 2

# TODO: When upgrading to Python 3.12, add type to the beginning of aliases
PathOrFile = str | os.PathLike[str] | BinaryIO
BinaryModes = Literal["rb", "wb"]


class FormatError(Exception):
    """The current input data does not conform to an expected format."""


class FileFormatError(FormatError):
    """The file does not conform to a file format or is malformed."""


def read_file(path_or_buf: PathOrFile) -> bytes:
    """Return contents of a file from a path-like object or file-like object."""
    if isinstance(path_or_buf, (str, os.PathLike)):
        return Path(path_or_buf).read_bytes()

    return path_or_buf.read()


def read_unicode_file(path_or_buf: PathOrFile) -> bytes:
    """Return the contents of a UTF-16 LE text file in bytes.

    Raises:
        FileFormatError:
            The file is not a UTF-16 little-endian encoded text file or is missing
            the Byte Order Mark for UTF-16 little-endian.
    """
    data = read_file(path_or_buf)

    if data[:UTF16_LENGTH] != BOM_UTF16_LE:
        raise FileFormatError(
            f"{get_file_name(path_or_buf)} is not a UTF-16 little-endian file"
        )

    return data[UTF16_LENGTH:]


def write_file(path_or_buf: PathOrFile, data: bytes) -> None:
    """Write bytes to a file from a path-like object or file-like object."""
    if isinstance(path_or_buf, (str, os.PathLike)):
        Path(path_or_buf).write_bytes(data)
        return

    path_or_buf.write(data)


def write_unicode_file(path_or_buf: PathOrFile, data: bytes) -> None:
    """Write UTF-16 LE encoded text to a file."""
    write_file(path_or_buf, BOM_UTF16_LE + data)


def get_file_name(path_or_buf: PathOrFile) -> str:
    """Return the name of the file from a path or a file-like object in binary mode."""
    if isinstance(path_or_buf, (str, os.PathLike)):
        return Path(os.fspath(path_or_buf)).name

    return Path(os.fspath(path_or_buf.name)).name
